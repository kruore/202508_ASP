
---


*스레싱(Threshing)**은 운영체제(OS), 특히 가상 메모리(Virtual Memory) 시스템에서 발생할 수 있는 가장 치명적인 성능 저하 현상 중 하나입니다.

스레싱을 단순한 '메모리 부족' 현상이 아닌, **시스템 리소스 관리의 임계점(Critical Point) 초과로 인한 피드백 루프의 붕괴** 관점에서 설명하겠습니다. 이를 위해 이론적 배경, 수학적 모델(Working Set), 메커니즘, 그리고 해결 전략으로 나누어 분석합니다.

---

### 1. 스레싱의 정의와 현상학적 본질

스레싱은 프로세스가 실제 유의미한 연산(Execution)을 수행하는 시간보다, 데이터 부재로 인한 **페이지 부재(Page Fault)**를 처리하고 페이지를 교체(Swapping in/out)하는 데 더 많은 시간을 소비하는 상태를 말합니다.

- **현상:** CPU 이용률(Utilization)이 급격히 떨어지고, 동시에 I/O 처리율이 폭증하며 시스템이 멈춘 듯한 상태(Hang)가 됩니다.
    
- **핵심 원인:** 다중 프로그래밍 정도(Degree of Multiprogramming, MPD)가 시스템이 수용 가능한 임계치를 초과했기 때문입니다.
    

> **핵심 통찰:** 스레싱은 OS의 스케줄러가 "CPU가 놀고 있다"고 오판하여 더 많은 프로세스를 메모리에 올리려 시도함으로써 상황을 악화시키는 **'악순환의 고리(Vicious Cycle)'**입니다.

---

### 2. 이론적 배경: 지역성(Locality)과 가상 메모리

스레싱을 이해하려면 가상 메모리의 대전제인 **참조의 지역성(Locality of Reference)**을 먼저 정립해야 합니다.

1. **시간적 지역성(Temporal Locality):** 최근에 참조된 페이지가 가까운 미래에 다시 참조될 확률이 높음.
    
2. **공간적 지역성(Spatial Locality):** 참조된 페이지의 인접 페이지가 참조될 확률이 높음.
    

가상 메모리는 이 지역성 원리에 기반하여 프로세스의 전체가 아닌 일부(Page)만 메모리에 적재합니다. 하지만, 프로세스가 원활하게 수행되기 위해 필요한 최소한의 페이지 집합이 메모리에 보장되지 않으면, 지역성 원리가 깨지며 빈번한 Page Fault가 발생합니다.

---

### 3. 메커니즘 분석: MPD와 CPU 이용률의 관계

스레싱 발생 과정을 시스템 다이내믹스 관점에서 분석하면 다음과 같습니다.

1. **초기 단계 (MPD 증가 $\rightarrow$ CPU 이용률 증가):**
    
    - 메모리에 프로세스가 로드될수록 I/O 대기 시간 동안 다른 프로세스가 CPU를 사용하므로 전체 시스템 효율이 증가합니다.
        
2. **임계점 (Saturation Point):**
    
    - 메모리가 가득 차고, 각 프로세스에 할당된 프레임(Frame) 수가 줄어듭니다.
        
3. **스레싱 발생 (MPD 과다 $\rightarrow$ 급격한 성능 하락):**
    
    - 프로세스들이 자신의 **Working Set(작업 집합)**을 확보하지 못하게 됩니다.
        
    - **Page Fault** 발생 빈도가 급증합니다.
        
    - **CPU 스케줄러의 오판:** Page Fault 처리(Disk I/O)로 인해 프로세스들이 대기 상태(Waiting State)로 전환됩니다. 준비 큐(Ready Queue)가 비게 되자, CPU 이용률이 낮아집니다.
        
    - **피드백 오류:** OS는 CPU 이용률을 높이기 위해 새로운 프로세스를 메모리에 로드(Swap-in)합니다. 이는 메모리 부족을 가속화하며 시스템을 붕괴시킵니다.
        

---

### 4. 수학적 모델링과 할당 이론

스레싱을 방지하기 위한 이론적 모델은 **Peter Denning**의 **워킹 셋(Working Set) 모델**이 대표적입니다.

#### 4.1. 워킹 셋 모델 (The Working Set Model)

프로세스 $P_i$가 시간 $t$에 참조한 페이지들의 집합을 정의합니다.

$$W(t, \Delta) = \{ p \in P \mid \text{page } p \text{ was referenced in time interval } (t-\Delta, t) \}$$

여기서 $\Delta$는 **워킹 셋 윈도우(Working Set Window)** 크기입니다.

- **WSS (Working Set Size):** $|W(t, \Delta)|$는 프로세스가 원활히 돌기 위해 필요한 고유 페이지 수입니다.
    
- **메모리 요구량의 총합:** $D = \sum WSS_i$
    

#### 4.2. 스레싱 조건

시스템의 총 물리 메모리 프레임 수를 $M$이라고 할 때:

$$\text{If } D > M \Rightarrow \text{Thrashing occurs}$$

즉, 모든 활성 프로세스들의 워킹 셋 크기의 합이 물리 메모리보다 크면 스레싱이 발생합니다. 반대로 $D \ll M$이면 메모리 낭비가 발생합니다.

#### 4.3. 페이지 부재 빈도 (PFF, Page Fault Frequency)

워킹 셋을 직접 계산하는 것은 오버헤드가 크므로, 근사치로 **PFF**를 사용합니다.

- **상한선(Upper Bound):** Page Fault율이 이 값을 넘으면 프레임을 더 할당합니다.
    
- **하한선(Lower Bound):** Page Fault율이 이 값보다 낮으면 프레임을 회수합니다.
    

---

### 5. 해결 및 방지 전략 (Mitigation Strategies)

스레싱은 하드웨어 증설뿐만 아니라 알고리즘적 제어를 통해 해결해야 합니다.

#### 5.1. 로드 제어 (Load Control)

가장 직접적인 해결책은 **MPD(다중 프로그래밍 정도)를 낮추는 것**입니다.

- **프로세스 중단 (Swapping Out):** 우선순위가 낮거나, 막 시작된 프로세스, 혹은 크기가 큰 프로세스를 희생양(Victim)으로 선정하여 디스크의 스왑 영역(Swap Space)으로 내보냅니다.
    
- **LTS (Long-Term Scheduler) 조정:** 시스템에 진입하는 프로세스의 속도를 조절합니다.
    

#### 5.2. 지역 할당(Local Replacement) 우선 사용

- **전역 교체(Global Replacement):** 다른 프로세스의 프레임까지 뺏어올 수 있는 방식은 스레싱 전파 위험이 있습니다. 하나의 프로세스가 스레싱에 빠지면 다른 프로세스의 프레임을 뺏고, 결국 전체 시스템이 스레싱에 빠집니다.
    
- **지역 교체(Local Replacement):** 스레싱이 발생하더라도 해당 프로세스 내에서만 국한되도록 제한합니다. (단, 메모리 효율성은 떨어질 수 있음)
    

#### 5.3. 커널/하드웨어 튜닝

- **Huge Pages 사용:** TLB(Translation Lookaside Buffer) 히트율을 높이고 페이지 테이블 오버헤드를 줄여 간접적으로 메모리 압박을 완화합니다.
    
- **SSD/NVMe 활용:** Page Fault 발생 시 디스크 I/O 레이턴시(Latency)를 줄여 스레싱의 충격을 완화합니다. (근본적 해결책은 아님)
    

---

### 6. 결론 및 요약

스레싱은 **"제한된 자원(물리 메모리)에 대한 수요(가상 메모리 총합)가 임계치를 넘어설 때 발생하는 시스템 붕괴 현상"**입니다. 이를 해결하기 위해서는 단순히 메모리를 늘리는 것을 넘어, 운영체제가 프로세스의 **Working Set**을 보장해주고, 필요시 과감하게 **Load Control**을 수행하여 $D \le M$ 상태를 유지해야 합니다.

현대 OS(Linux, Windows)는 복잡한 LRU(Least Recently Used) 근사 알고리즘과 정교한 Swapping 정책을 통해 이를 자동으로 제어하고 있습니다.