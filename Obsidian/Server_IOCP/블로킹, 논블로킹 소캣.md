
---

**블로킹(Blocking) 소켓**과 **논 블로킹(Non-blocking) 소켓**의 차이는 네트워크 프로그래밍, 특히 **고성능 서버 아키텍처**를 설계할 때 가장 기초적이면서도 핵심이 되는 개념입니다.

이 둘의 본질적인 차이는 **"시스템 콜(System Call) 요청 시, 커널(Kernel)이 제어권(Control)을 언제 다시 어플리케이션(User Process)으로 돌려주는가?"**에 있습니다.

이를 운영체제 레벨의 I/O 모델 관점에서 상세히 분석해 드리겠습니다.

---

### 1. 기본 개념: I/O의 두 단계

소켓 통신에서 `read` 혹은 `recv`와 같은 입력 연산은 물리적으로 두 단계를 거칩니다.

1. **Wait for Data:** 데이터가 네트워크를 타고 도착하여 커널의 수신 버퍼(RX Buffer)에 찰 때까지 기다리는 단계.
    
2. **Copy Data:** 커널 버퍼에 있는 데이터를 유저 프로세스 메모리 공간으로 복사하는 단계.
    

블로킹과 논 블로킹은 주로 **1번 단계**를 어떻게 처리하느냐에 따라 갈립니다.

---

### 2. 블로킹 소켓 (Blocking Socket)

가장 기본적이고 직관적인 모델입니다. 소켓을 생성하면 기본값(Default)은 블로킹 모드입니다.

#### 메커니즘

1. **요청:** 어플리케이션이 `recv()`를 호출합니다.
    
2. **대기 (Block):** 커널 버퍼에 데이터가 없다면, 커널은 해당 프로세스(또는 스레드)를 **대기 상태(Waiting/Sleep State)**로 변경합니다.
    
    - 이때 CPU 제어권은 다른 프로세스로 넘어갑니다 (**Context Switch**).
        
3. **반환:** 데이터가 도착하면 인터럽트가 발생하고, 커널이 데이터를 유저 공간으로 복사한 후 프로세스를 **준비 상태(Ready State)**로 깨웁니다. `recv()` 함수가 리턴되며 제어권이 돌아옵니다.
    

#### 특징 및 문제점

- **직관성:** 코드가 순차적(Sequential)이어서 작성하고 이해하기 쉽습니다.
    
- **비효율성 (확장성 문제):**
    
    - 하나의 클라이언트를 처리하는 동안 스레드가 멈춰 있습니다.
        
    - 동시 접속자가 많아지면 `1 Client = 1 Thread` 모델을 써야 하는데, **스레드 생성 비용**과 잦은 **컨텍스트 스위칭(Context Switching)** 오버헤드로 인해 시스템 성능이 급격히 저하됩니다. (C10K 문제의 원인)
        

---

### 3. 논 블로킹 소켓 (Non-blocking Socket)

소켓을 논 블로킹 모드로 설정(`fcntl` 등을 사용)한 상태입니다.

#### 메커니즘

1. **요청:** 어플리케이션이 `recv()`를 호출합니다.
    
2. **즉시 반환:**
    
    - **데이터가 있을 경우:** 데이터를 복사하고 성공적으로 리턴합니다.
        
    - **데이터가 없을 경우:** 프로세스를 재우지 않고, **즉시 에러 코드(`EWOULDBLOCK` 또는 `EAGAIN`)를 반환**합니다.
        
3. **반복:** 어플리케이션은 데이터가 도착했는지 확인하기 위해 반복적으로 시스템 콜을 호출해야 합니다.
    

#### 특징 및 문제점

- **제어권 유지:** I/O 작업 때문에 스레드가 멈추지 않으므로, 하나의 스레드로 여러 작업을 수행할 수 있습니다.
    
- **비지 웨이팅 (Busy Waiting/Spinning):**
    
    - 데이터가 올 때까지 루프를 돌며 계속 `recv()`를 호출하면, **의미 없는 CPU 사이클을 소모**하게 됩니다. 이는 심각한 자원 낭비입니다.
        
    - 따라서 단독으로 쓰이기보다는 **I/O 멀티플렉싱**과 결합될 때 진가를 발휘합니다.
        

---

### 4. 심화: I/O 멀티플렉싱 (Multiplexing)과의 결합

논 블로킹 소켓의 "확인하고 바로 리턴하는" 특성은 `select`, `poll`, `epoll`(Linux), `kqueue`(BSD), `IOCP`(Windows)와 같은 **이벤트 통지(Event Notification)** 모델과 결합하여 고성능 서버를 만듭니다.

1. **구독:** 1,000개의 논 블로킹 소켓을 `epoll` 객체에 등록(구독)합니다.
    
2. **대기:** 어플리케이션은 개별 소켓의 `read`를 호출하는 대신, `epoll_wait`을 호출하여 **"이벤트가 발생할 때까지"** 대기합니다. (이때는 블로킹됩니다)
    
3. **처리:** 데이터가 도착한 소켓 목록을 `epoll`이 반환해주면, 어플리케이션은 **해당 소켓들에 대해서만** `read`를 수행합니다.
    
    - 이때의 `read`는 데이터가 있음이 보장되므로 블로킹되지 않고 즉시 데이터를 가져옵니다.
        

> **결론:** 현대의 Nginx, Node.js, Redis 같은 고성능 서버들은 **"논 블로킹 소켓 + I/O 멀티플렉싱"** 방식을 사용하여, 단일 스레드(또는 소수의 스레드)로 수만 개의 동시 연결을 처리합니다.

---

### 5. 비교 요약 (Comparison Table)

|**구분**|**블로킹 (Blocking)**|**논 블로킹 (Non-blocking)**|
|---|---|---|
|**동작 방식**|요청 즉시 대기, 완료 시 리턴|요청 즉시 리턴 (완료 또는 에러)|
|**CPU 점유**|대기 시간 동안 점유하지 않음 (Sleep)|루프를 돌며 계속 확인할 경우 과다 점유 (Busy Wait)|
|**코드 복잡도**|단순함 (순차적)|복잡함 (에러 처리 및 상태 관리 필요)|
|**사용 사례**|간단한 클라이언트, 배치 작업, 낮은 동시성|**고성능 서버**, 실시간 통신, UI 스레드(응답성 유지)|
|**관련 에러**|없음 (그냥 기다림)|`EWOULDBLOCK`, `EAGAIN`|

---

### 6. 오해하기 쉬운 개념: 비동기(Asynchronous) I/O와의 차이

많은 개발자가 **논 블로킹**과 **비동기(Asynchronous)**를 혼용하지만, 엄밀히는 다릅니다.

- **Synchronous Non-blocking (동기 논 블로킹):**
    
    - "데이터 있어?"라고 계속 물어보는 것(Polling).
        
    - `read` 호출 시 데이터 복사(Kernel $\to$ User)는 **동기적**으로 일어납니다(복사하는 동안 CPU 사용).
        
    - 대부분의 `select/epoll` 기반 서버가 이 방식입니다.
        
- **Asynchronous I/O (비동기 I/O, AIO):**
    
    - "데이터 다 받으면 나한테 알려줘(Callback/Signal)"라고 요청하고 잊어버리는 것.
        
    - 데이터 복사까지 커널이 완료한 후 어플리케이션에 통지합니다.
        
    - Windows의 **IOCP**, 리눅스의 **io_uring**이 이 모델에 가깝습니다.
        

---

### 7. 한 줄 요약 및 제안

- **블로킹:** "주문하고 음식이 나올 때까지 카운터 앞에서 멍하니 서 있는 손님"
    
- **논 블로킹:** "주문하고 1초마다 '나왔어요?'라고 물어보는 손님 (진동벨이 없다면)"
    
- **논 블로킹 + 멀티플렉싱:** "진동벨을 가지고 자리에 앉아 있다가, 벨이 울리면 가서 받아오는 손님"



[[Overlapped]]
