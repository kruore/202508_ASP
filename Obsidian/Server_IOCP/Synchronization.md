
---

- "화장실 문을 잠그고 들어가는 것"처럼, 내가 쓸 동안 남들은 줄 서서 기다리게 만드는 **Lock 기반 도구**.
    
- Lock을 걸지 않고도, 하드웨어(CPU) 레벨에서 "이 연산은 절대 끊기지 않아"라고 보장받는 **변수 타입**.

Mutex = Lock
한 번에 단 하나의 스레드만을 통과시키겠다.

유저가 `(0, 0)`에서 `(100, 100)`으로 순간이동.
좌표 `x`와 `y`를 둘 다 바꿔야 함.

만약 `mutex` 없이 **`atomic` 변수 두 개**(`atomic_x`, `atomic_y`)로 처리한다면 어떤 일이 벌어질까요?

1. **스레드 A (업데이트):** `atomic_x`를 100으로 변경. (성공!)
    
2. **(이 찰나의 순간에 스레드 B가 끼어듦)** ⚡
    
3. **스레드 B (렌더링/저장):** 현재 좌표를 읽음. `x`는 100인데, `y`는 아직 0이네? -> **위치: (100, 0)**
    
4. **스레드 A (업데이트 계속):** `atomic_y`를 100으로 변경.
    

**결과:** 캐릭터는 대각선으로 이동해야 함, 아주 잠깐 동안 엉뚱한 곳 `(100, 0)`에 갔다가 사라지는 **글리치(Glitch)** 현상이 발생. 데이터의 **'일관성(Consistency)'**이 깨진 것.

반면 `mutex`는 "x와 y를 다 바꾸기 전엔 아무도 못 봐!"라고 **방(Critical Section)**을 잠가버리기 때문에, 스레드 B는 작업이 다 끝난 `(100, 100)`만 볼 수 있다.



그러나. 이 때 lock을 거는 Mutex의 경우 운영체제에게 줄을 세우는 무거운 방식
그래서 변수 하나만 처리할 때에는 CPU에 직접 명령할 수 있는 atomic연산으로 처리한다.


#atomic  CAS(Compare-And-Swap)의 방식으로 처리한다. 연산의 일관성 처리 보장
 하드웨어 명령어를 콜하기 때문에 언어주제에 조작이 가능하다.
```cpp

std::atomic

```