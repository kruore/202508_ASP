
---


포인터에 대한 정리.

1. 포인터는 기본적으로 메모리의 가상 주소를 가르킨다.
2. 포인터가 메모리를 가르키고 있을 때 * 를 사용한다.
3. ** 를 사용하여 포인터의 포인터를 가르키면 값이 나온다. 이는 &과 같으나 &는 레퍼런스로 해당 레퍼런스를 사용하게 되면, null을 허용하지 않아서 좋다.
4. 값을 수정하기 싫다면. readonly의 경우 앞에 const를 붙여서 상수로 사용한다.


#unique_pointer
모던 C++에 대하여
```cpp

//코드 스니펫


// unique_ptr 내부 구현의 느낌 
unique_ptr(const unique_ptr&) = delete; // 복사 금지!
unique_ptr& operator=(const unique_ptr&) = delete; // 대입 금지!
 
// 유니크 포인터는 기본적으로 Move만을 가능한다.
// C++11에서 도입된 **이동 시맨틱(Move Semantics)**을 사용하면 소유권을 `p2`에게 완전히 넘겨줄 수 있다.

std::unique_ptr<User> p1 = std::make_unique<User>();
std::unique_ptr<User> p2 = std::move(p1);

//Move 이후의 상황을 추론.
// 그럼 p1은 이후에 어떻게 될 것인가?


```
 이동(`move`)된 `unique_ptr`은 **명확하게 `nullptr`(0) 상태가 된다.**

이게 왜 중요하냐면, `p1`이 `nullptr`이 되었기 때문에 나중에 `p1`의 소멸자가 호출되더라도 **아무런 동작도 하지 않게(delete nullptr는 안전함)** 되어 '중복 해제(Double Free)' 에러를 막아주기 때문이다.

#shared_ptr

```cpp

#include <iostream>

template <typename T>
class SimpleSharedPtr {
private:
    T* ptr;             // 실제 객체를 가리키는 포인터
    int* ref_count;     // 몇 명이 공유 중인지 세는 카운터 (제어 블록의 일부)

public:
    // 1. 생성자: 객체를 처음 만들 때
    SimpleSharedPtr(T* p = nullptr) : ptr(p) {
        if (ptr) {
            ref_count = new int(1); // 카운트 1로 시작
            std::cout << "생성: 카운트 1 (Resource 할당)\n";
        } else {
            ref_count = nullptr;
        }
    }

    // 2. 복사 생성자: 이미 있는 shared_ptr를 복사할 때 (핵심!)
    SimpleSharedPtr(const SimpleSharedPtr& other) {
        ptr = other.ptr;            // 같은 객체를 가리킴
        ref_count = other.ref_count; // 같은 카운터를 공유함
        if (ref_count) {
            (*ref_count)++;         // 카운트 증가!
            std::cout << "복사: 카운트 증가 -> " << *ref_count << "\n";
        }
    }

    // 3. 소멸자: shared_ptr가 사라질 때
    ~SimpleSharedPtr() {
        if (ref_count) {
            (*ref_count)--;         // 카운트 감소
            std::cout << "소멸: 카운트 감소 -> " << *ref_count << "\n";

            if (*ref_count == 0) {  // 0이 되면 진짜 삭제!
                delete ptr;
                delete ref_count;
                std::cout << "카운트 0 도달: 메모리 완전 해제!\n";
            }
        }
    }

    // 데이터 접근을 위한 연산자 오버로딩
    T& operator*() { return *ptr; }
    T* operator->() { return ptr; }
};

```

제어 블록(Control Block)